// We are given a rod of size ‘N’. It can be cut into pieces.
// Each length of a piece has a particular price given by the price array.
// Our task is to find the maximum revenue that can be generated by selling 
// the rod after cutting( if required) into pieces.

#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

// ------------------------ 1. Pure Recursion ------------------------
// Time Complexity: Exponential O(2^n)
// Space Complexity: O(n) (recursive stack)

int cutRodRec(int index, int N, vector<int> &price) {
    if (index == 0) {
        return N * price[0];  // Only cut of length 1 is possible
    }

    int notTake = cutRodRec(index - 1, N, price);
    int take = -1e9;
    int rodLength = index + 1;

    if (rodLength <= N) {
        take = price[index] + cutRodRec(index, N - rodLength, price);
    }

    return max(take, notTake);
}

// ------------------------ 2. Memoization ------------------------
// Time Complexity: O(n^2)
// Space Complexity: O(n^2) + O(n) (DP + recursion stack)

int cutRodMemo(int index, int N, vector<int> &price, vector<vector<int>> &dp) {
    if (index == 0) {
        return N * price[0];
    }

    if (dp[index][N] != -1) return dp[index][N];

    int notTake = cutRodMemo(index - 1, N, price, dp);
    int take = -1e9;
    int rodLength = index + 1;

    if (rodLength <= N) {
        take = price[index] + cutRodMemo(index, N - rodLength, price, dp);
    }

    return dp[index][N] = max(take, notTake);
}

// ------------------------ 3. Tabulation (Bottom-Up) ------------------------
// Time Complexity: O(n^2)
// Space Complexity: O(n^2)

int cutRodTab(int n, vector<int> &price) {
    vector<vector<int>> dp(n, vector<int>(n + 1, 0));

    // Base case: Fill first row
    for (int N = 0; N <= n; N++) {
        dp[0][N] = N * price[0];
    }

    for (int index = 1; index < n; index++) {
        for (int N = 0; N <= n; N++) {
            int notTake = dp[index - 1][N];
            int take = -1e9;
            int rodLength = index + 1;
            if (rodLength <= N) {
                take = price[index] + dp[index][N - rodLength];
            }
            dp[index][N] = max(take, notTake);
        }
    }

    return dp[n - 1][n];
}

int main() {
    int n = 8;
    vector<int> price = {1, 5, 8, 9, 10, 17, 17, 20};

    // 1. Recursion
    cout << "Recursion: Max Profit = " << cutRodRec(n - 1, n, price) << endl;

    // 2. Memoization
    vector<vector<int>> dp(n, vector<int>(n + 1, -1));
    cout << "Memoization: Max Profit = " << cutRodMemo(n - 1, n, price, dp) << endl;

    // 3. Tabulation
    cout << "Tabulation: Max Profit = " << cutRodTab(n, price) << endl;

    return 0;
}
